<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>hserus2</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f9fafb; color: #111; margin: 20px; }
    h1 { text-align: center; }
    button { padding: 8px 16px; margin: 10px 0; cursor: pointer; border: none; border-radius: 6px; background: #2563eb; color: #fff; }
    #status { margin: 10px 0; font-weight: bold; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { padding: 8px 12px; border: 1px solid #ddd; text-align: center; }
    th { background: #f3f4f6; cursor: pointer; }
    tr:nth-child(even) { background: #f9f9f9; }
  </style>
</head>
<body>
  <h1>hserus2</h1>
  <button onclick="refreshData()">Refresh</button>
  <div id="status">Idle</div>
  <table id="screener">
    <thead>
      <tr>
        <th onclick="sortTable(0)">Symbol</th>
        <th onclick="sortTable(1)">Close % Chg</th>
        <th onclick="sortTable(2)">Volume % Chg</th>
        <th onclick="sortTable(3)">Prev BB Squeeze %</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    const API_KLINES = "https://fapi.binance.com/fapi/v1/klines";
    const API_EXCHANGEINFO = "https://fapi.binance.com/fapi/v1/exchangeInfo";
    const API_TICKER24H = "https://fapi.binance.com/fapi/v1/ticker/24hr";
    const excludeSymbols = ["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TRXUSDT","MATICUSDT","DOTUSDT","TONUSDT","LTCUSDT","BCHUSDT","AVAXUSDT","LINKUSDT","UNIUSDT","XLMUSDT","OPUSDT","ETCUSDT","NEARUSDT"];

    async function fetchSymbols() {
      // Get all futures symbols
      let resInfo = await fetch(API_EXCHANGEINFO);
      let dataInfo = await resInfo.json();
      let symbolsAll = dataInfo.symbols.filter(s=>s.contractType==="PERPETUAL").map(s=>s.symbol);

      // Get 24h stats
      let resTick = await fetch(API_TICKER24H);
      let tickers = await resTick.json();

      // Filter only perpetual symbols
      let filtered = tickers.filter(t => symbolsAll.includes(t.symbol));

      // Sort by 24h volume (quoteVolume)
      filtered.sort((a,b)=> parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));

      // Exclude top 20 by global market cap symbols
      let symbols = filtered.map(t=>t.symbol).filter(s=>!excludeSymbols.includes(s));

      // Take top 200
      return symbols.slice(0,200);
    }

    async function fetchKlines(symbol, interval="1h", limit=25) {
      let url = `${API_KLINES}?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      let res = await fetch(url);
      return res.json();
    }

    function calcBollinger(closes, period=20, mult=2) {
      let sma = [], upper = [], lower = [];
      for (let i=0; i<closes.length; i++) {
        if (i < period-1) { sma.push(null); upper.push(null); lower.push(null); continue; }
        let slice = closes.slice(i-period+1, i+1);
        let mean = slice.reduce((a,b)=>a+b,0)/period;
        let variance = slice.reduce((a,b)=>a+(b-mean)**2,0)/period;
        let stdev = Math.sqrt(variance);
        sma.push(mean);
        upper.push(mean + mult*stdev);
        lower.push(mean - mult*stdev);
      }
      return { sma, upper, lower };
    }

    async function checkSymbol(symbol) {
      try {
        let klines = await fetchKlines(symbol);
        if (!klines || klines.length < 22) return null;

        let closes = klines.map(k => parseFloat(k[4]));
        let volumes = klines.map(k => parseFloat(k[5]));
        let opens = klines.map(k => parseFloat(k[1]));
        let highs = klines.map(k => parseFloat(k[2]));
        let lows = klines.map(k => parseFloat(k[3]));

        let last = klines.length-1;
        let prev = last-1;
        let prevprev = last-2;

        // (1) volume condition
        if (!(volumes[last] > volumes[prev] && volumes[last] > volumes[prevprev])) return null;

        // Bollinger
        let {sma, upper, lower} = calcBollinger(closes);
        let prevBandWidth = upper[prev] - lower[prev];
        let prevPrevBandWidth = upper[prevprev] - lower[prevprev];
        if (prevBandWidth > prevPrevBandWidth) return null; // not squeezing

        let currGreen = closes[last] > opens[last];
        let breakout = false;
        if (currGreen && (highs[last] > upper[last] || highs[last] > sma[last])) breakout = true;
        if (!currGreen && (lows[last] < lower[last] || lows[last] < sma[last])) breakout = true;
        if (!breakout) return null;

        // Metrics
        let closeChange = ((closes[last] - closes[prev]) / closes[prev]) * 100;
        let volChange = ((volumes[last] - volumes[prev]) / volumes[prev]) * 100;
        let squeezeChange = ((prevBandWidth - prevPrevBandWidth) / prevPrevBandWidth) * 100;

        return {
          symbol,
          closeChange: closeChange.toFixed(2)+"%",
          volChange: volChange.toFixed(2)+"%",
          squeezeChange: squeezeChange.toFixed(2)+"%"
        };
      } catch(e) {
        console.error(symbol, e);
        return null;
      }
    }

    async function refreshData() {
      document.querySelector("tbody").innerHTML = "<tr><td colspan='4'>Loading symbols...</td></tr>";
      document.getElementById("status").innerText = "Fetching top 200 symbols...";
      let symbols = await fetchSymbols();

      let results = [];
      for (let i=0;i<symbols.length;i++) {
        document.getElementById("status").innerText = `Scanning ${i+1}/${symbols.length}: ${symbols[i]}`;
        let row = await checkSymbol(symbols[i]);
        if (row) results.push(row);
      }

      let tbody = document.querySelector("tbody");
      tbody.innerHTML = "";
      if (results.length === 0) {
        tbody.innerHTML = "<tr><td colspan='4'>No matches found</td></tr>";
      } else {
        results.forEach(r=>{
          tbody.innerHTML += `<tr>
            <td>${r.symbol}</td>
            <td>${r.closeChange}</td>
            <td>${r.volChange}</td>
            <td>${r.squeezeChange}</td>
          </tr>`;
        });
      }
      document.getElementById("status").innerText = "Scan complete";
    }

    function sortTable(col) {
      let table = document.getElementById("screener");
      let rows = Array.from(table.rows).slice(1);
      let asc = table.getAttribute("data-sort-col")==col && table.getAttribute("data-sort-dir")=="asc" ? false : true;
      rows.sort((a,b)=>{
        let x = a.cells[col].innerText.replace("%","");
        let y = b.cells[col].innerText.replace("%","");
        return asc ? x-y : y-x;
      });
      rows.forEach(r=>table.tBodies[0].appendChild(r));
      table.setAttribute("data-sort-col", col);
      table.setAttribute("data-sort-dir", asc ? "asc":"desc");
    }
  </script>
</body>
</html>
