<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Hserus 2</title>
  <style>
    :root{--bg:#071827;--card:#0b2430;--muted:#9fb6c7;--accent:#7be3c7;--danger:#ff9a9a}
    body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#021119 0%,#051521 100%);color:#e6f3f6;padding:12px}
    header{display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:8px}
    h1{font-size:18px;margin:0}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    select,button{padding:8px;border-radius:8px;border:1px solid #12333d;background:var(--card);color:inherit}
    button{cursor:pointer}
    #status{font-size:13px;color:var(--muted)}
    main{margin-top:12px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{text-align:left;padding:10px;border-bottom:1px solid rgba(255,255,255,0.04)}
    th{color:var(--muted);font-size:12px}
    tr.match{background:linear-gradient(90deg, rgba(11,36,48,0.8), rgba(6,28,36,0.6));border-radius:6px}
    .small{font-size:12px;color:var(--muted)}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:#07353a;color:var(--accent);font-weight:600}
    @media(max-width:640px){ th,td{padding:8px;font-size:12px} h1{font-size:16px} }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Hserus 2</h1>
      <div class="small">Conditions: last two candle colours different; MACD histogram trend matching candle color (last 3).</div>
    </div>

    <div class="controls">
      <label class="small">Sort:
        <select id="sortOpt">
          <option value="none">None</option>
          <option value="close_desc">Close % ↓</option>
          <option value="close_asc">Close % ↑</option>
          <option value="rsi_desc">RSI ↓</option>
          <option value="rsi_asc">RSI ↑</option>
        </select>
      </label>

      <button id="refreshBtn">Refresh</button>
      <div id="status">Ready</div>
    </div>
  </header>

  <main>
    <table aria-live="polite">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Close Δ %</th>
          <th>RSI(6)</th>
          <th>MACD hist (t-2, t-1, t)</th>
          <th class="small">Note</th>
        </tr>
      </thead>
      <tbody id="resultsBody">
        <tr><td colspan="5" class="small">Click Refresh to scan — progress updates will appear here (e.g. Scanning 12/200)</td></tr>
      </tbody>
    </table>
  </main>

<script>
/* Single-file client-side screener
   - LIMIT = 40 candles
   - Conditions:
     1) last 2 candles have different colors (doji ignored)
     2) red current -> hist[-3] < hist[-2] < hist[-1]
        green current -> hist[-3] > hist[-2] > hist[-1]
   - Displays close % change, RSI(6) (Wilder), MACD histogram last 3
   - Shows scanning progress (scanning i / N)
*/

const LIMIT = 40;
const INTERVAL = '1h';
const MAX_SYMBOLS = 200;
const EXCLUDE = ["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TONUSDT","AVAXUSDT","DOTUSDT","TRXUSDT","SHIBUSDT","LINKUSDT","NEARUSDT","MATICUSDT","LTCUSDT","UNIUSDT","BCHUSDT","ICPUSDT","LEOUSDT"];

const statusEl = document.getElementById('status');
const resultsBody = document.getElementById('resultsBody');
const refreshBtn = document.getElementById('refreshBtn');
const sortOpt = document.getElementById('sortOpt');

let matches = [];

refreshBtn.addEventListener('click', () => handleRefresh());
sortOpt.addEventListener('change', () => renderMatches());

async function fetchPerpetualSymbols() {
  const url = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
  const res = await fetch(url);
  if (!res.ok) throw new Error('exchangeInfo failed');
  const data = await res.json();
  return data.symbols
    .filter(s => s.contractType === 'PERPETUAL' && s.symbol.endsWith('USDT') && !EXCLUDE.includes(s.symbol))
    .map(s => s.symbol);
}

async function fetchTopSymbols(limit = MAX_SYMBOLS) {
  // Use 24hr ticker to pick most active / volatile
  const url = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
  const [tickRes, perpSymbols] = await Promise.all([fetch(url), fetchPerpetualSymbols()]);
  if (!tickRes.ok) throw new Error('ticker24h failed');
  const tick = await tickRes.json();
  const filtered = tick
    .filter(t => t.symbol.endsWith('USDT') && perpSymbols.includes(t.symbol))
    .sort((a,b) => Math.abs(parseFloat(b.priceChangePercent || 0)) - Math.abs(parseFloat(a.priceChangePercent || 0)))
    .slice(0, limit)
    .map(t => t.symbol);
  return filtered;
}

async function fetchKlines(symbol) {
  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=${LIMIT}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`klines failed ${symbol}`);
  const raw = await res.json();
  return raw.map(r => ({
    open: +r[1], high: +r[2], low: +r[3], close: +r[4], volume: +r[5]
  }));
}

/* Wilder RSI implementation in JS */
function rsiWilderFromCloses(closes, period = 6) {
  const n = closes.length;
  const deltas = new Array(n).fill(0);
  for (let i=1; i<n; i++) deltas[i] = closes[i] - closes[i-1];

  const gains = new Array(n).fill(0), losses = new Array(n).fill(0);
  for (let i=1; i<n; i++) {
    if (deltas[i] > 0) { gains[i] = deltas[i]; losses[i] = 0; }
    else { gains[i] = 0; losses[i] = -deltas[i]; }
  }

  const avgGain = new Array(n).fill(null), avgLoss = new Array(n).fill(null);
  if (n <= period) return new Array(n).fill(null);

  // initial averages at index = period
  let sumG = 0, sumL = 0;
  for (let i=1; i<=period; i++) { sumG += gains[i]; sumL += losses[i]; }
  avgGain[period] = sumG / period;
  avgLoss[period] = sumL / period;

  for (let i=period+1; i<n; i++) {
    avgGain[i] = (avgGain[i-1] * (period - 1) + gains[i]) / period;
    avgLoss[i] = (avgLoss[i-1] * (period - 1) + losses[i]) / period;
  }

  const rsi = new Array(n).fill(null);
  for (let i=0;i<n;i++) {
    if (avgGain[i] == null || avgLoss[i] == null) rsi[i] = null;
    else if (avgLoss[i] === 0) rsi[i] = 100;
    else {
      const rs = avgGain[i] / avgLoss[i];
      rsi[i] = 100 - (100 / (1 + rs));
    }
  }
  return rsi;
}

/* EMA array (simple) */
function emaArray(values, period) {
  const k = 2 / (period + 1);
  const out = new Array(values.length).fill(null);
  out[0] = values[0];
  for (let i=1; i<values.length; i++) {
    out[i] = values[i] * k + out[i-1] * (1 - k);
  }
  return out;
}

/* MACD histogram arrays */
function macdArrays(closes, short=12, long=26, signal=9) {
  const emaShort = emaArray(closes, short);
  const emaLong = emaArray(closes, long);
  const macd = closes.map((_,i) => (emaShort[i] !== undefined && emaLong[i] !== undefined) ? (emaShort[i] - emaLong[i]) : 0);
  const signalArr = emaArray(macd, signal);
  const hist = macd.map((v,i) => v - signalArr[i]);
  return { macd, signalArr, hist };
}

/* Condition helpers */
function candleColor(c) {
  if (c.close > c.open) return 'green';
  if (c.close < c.open) return 'red';
  return 'doji';
}
function checkColorChange(prevC, lastC) {
  const pc = candleColor(prevC), lc = candleColor(lastC);
  return (pc !== lc) && (pc !== 'doji') && (lc !== 'doji');
}
function histIncreasingLast3(hist) {
  if (hist.length < 3) return false;
  const a = hist[hist.length-3], b = hist[hist.length-2], c = hist[hist.length-1];
  return (a < b) && (b < c);
}
function histDecreasingLast3(hist) {
  if (hist.length < 3) return false;
  const a = hist[hist.length-3], b = hist[hist.length-2], c = hist[hist.length-1];
  return (a > b) && (b > c);
}
function closeChangePct(prevClose, lastClose) {
  if (!prevClose) return 0;
  return ((lastClose - prevClose) / prevClose) * 100;
}

/* Visual helpers */
function appendMatchRow(obj) {
  const tr = document.createElement('tr');
  tr.className = 'match';
  tr.innerHTML = `
    <td><strong>${obj.symbol}</strong></td>
    <td>${obj.closePct.toFixed(2)}%</td>
    <td>${obj.rsi.toFixed(2)}</td>
    <td class="small">${obj.hist.map(v => v.toFixed(6)).join(', ')}</td>
    <td class="small">${obj.note || ''}</td>`;
  resultsBody.appendChild(tr);
}

function renderMatches() {
  // sort matches according to dropdown
  const opt = sortOpt.value;
  let sorted = [...matches];
  if (opt === 'close_desc') sorted.sort((a,b)=> b.closePct - a.closePct);
  else if (opt === 'close_asc') sorted.sort((a,b)=> a.closePct - b.closePct);
  else if (opt === 'rsi_desc') sorted.sort((a,b)=> b.rsi - a.rsi);
  else if (opt === 'rsi_asc') sorted.sort((a,b)=> a.rsi - b.rsi);

  // clear table body and re-render header row
  resultsBody.innerHTML = '';
  if (sorted.length === 0) {
    resultsBody.innerHTML = '<tr><td colspan="5" class="small">No matches yet.</td></tr>';
    return;
  }
  for (const m of sorted) appendMatchRow(m);
}

/* Main scanning loop with progress updates */
async function runScan() {
  try {
    matches = [];
    resultsBody.innerHTML = '<tr><td colspan="5" class="small">Preparing scan...</td></tr>';
    statusEl.textContent = 'Preparing symbols...';

    const symbols = await fetchTopSymbols(MAX_SYMBOLS);
    statusEl.textContent = `Scanning 0 / ${symbols.length}`;

    // sequential scan with small pause so UI updates and you see progress
    let i = 0;
    for (const sym of symbols) {
      i++;
      statusEl.textContent = `Scanning ${i} / ${symbols.length}: ${sym}`;
      try {
        const klines = await fetchKlines(sym);
        // ensure we have enough candles
        if (!klines || klines.length < 10) { await sleep(80); continue; }

        const last = klines[klines.length-1];
        const prev = klines[klines.length-2];
        // color change?
        if (!checkColorChange(prev, last)) { await sleep(80); continue; }

        // prepare arrays
        const closes = klines.map(k => k.close);
        const opens = klines.map(k => k.open);

        // RSI(6) using Wilder
        const rsiArr = rsiWilderFromCloses(closes, 6);
        const rsiNow = rsiArr[rsiArr.length - 1];
        if (rsiNow == null) { await sleep(80); continue; }

        // MACD hist
        const { hist } = macdArrays(closes, 12, 26, 9);
        // require >=3 hist values
        if (hist.length < 3) { await sleep(80); continue; }

        const currentColor = candleColor(last);
        let condOk = false;
        if (currentColor === 'red') condOk = histIncreasingLast3(hist);
        else if (currentColor === 'green') condOk = histDecreasingLast3(hist);
        else condOk = false;

        if (!condOk) { await sleep(80); continue; }

        // compute close % change vs previous close
        const prevClose = klines[klines.length-2].close;
        const lastClose = klines[klines.length-1].close;
        const closePct = closeChangePct(prevClose, lastClose);

        // Add match and immediately append a row so user sees it live
        const matchObj = {
          symbol: sym,
          closePct: Number(closePct),
          rsi: Number(rsiNow),
          hist: [hist[hist.length-3], hist[hist.length-2], hist[hist.length-1]],
          note: currentColor
        };
        matches.push(matchObj);
        appendMatchRow(matchObj);
      } catch (errSym) {
        // ignore symbol errors but keep scanning
        // console.warn('err', sym, errSym);
      }
      // tiny sleep so browser UI can update and to avoid bursts
      await sleep(90);
    }

    statusEl.textContent = `Scan complete — ${matches.length} matches found.`;
  } catch (err) {
    console.error(err);
    statusEl.textContent = 'Error: ' + (err.message || err);
  }
}

/* small sleep helper */
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function handleRefresh() {
  refreshBtn.disabled = true;
  resultsBody.innerHTML = '<tr><td colspan="5" class="small">Starting scan...</td></tr>';
  await runScan();
  refreshBtn.disabled = false;
}

// Auto run on load (comment out if you prefer manual)
handleRefresh();

</script>
</body>
</html>
