<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>hserus 2</title>
<style>
:root {
  --bg:#071827; --card:#0b2430; --muted:#9fb6c7; --accent:#7be3c7; --danger:#ff9a9a;
}
body {
  margin:0; font-family:Inter,Arial,Helvetica,sans-serif; background:linear-gradient(#021119,#051521); color:#e6f3f6; padding:14px;
}
header {display:flex; flex-wrap:wrap; justify-content:space-between; gap:12px; align-items:center;}
h1 {font-size:18px;margin:0;}
.controls {display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
select,button {padding:8px; border-radius:8px; border:1px solid #12333d; background:var(--card); color:inherit;}
button {cursor:pointer;}
#status {font-size:13px; color:var(--muted);}
main {margin-top:12px;}
table {width:100%; border-collapse:collapse; font-size:13px;}
th,td {text-align:left; padding:10px; border-bottom:1px solid rgba(255,255,255,0.04);}
th {color:var(--muted); font-size:12px;}
tr.match {background:linear-gradient(90deg, rgba(11,36,48,0.6), rgba(6,28,36,0.4));}
.small {font-size:12px;color:var(--muted);}
.green{color:#7be3c7}
.red{color:#ff9a9a}
@media(max-width:720px){ th,td{padding:8px;font-size:12px} h1{font-size:16px} }
</style>
</head>
<body>
<header>
  <div>
    <h1>hserus 2</h1>
    <div class="small">hserus 2</div>
  </div>
  <div class="controls">
    <label class="small">Sort:
      <select id="sortSelect" title="Choose sort column & order">
        <option value="shortDiff_desc">Short Diff ↓ (default)</option>
        <option value="shortDiff_asc">Short Diff ↑</option>
        <option value="prevClose_desc">Prev Close % ↓</option>
        <option value="prevClose_asc">Prev Close % ↑</option>
        <option value="currClose_desc">Curr Close % ↓</option>
        <option value="currClose_asc">Curr Close % ↑</option>
        <option value="currVol_desc">Curr Vol % ↓</option>
        <option value="currVol_asc">Curr Vol % ↑</option>
        <option value="prevVol_desc">Prev Vol % ↓</option>
        <option value="prevVol_asc">Prev Vol % ↑</option>
        <option value="condA_desc">cond_a ↓</option>
        <option value="condA_asc">cond_a ↑</option>
        <option value="short1hChange_desc">Short 1h %chg ↓</option>
        <option value="short1hChange_asc">Short 1h %chg ↑</option>
      </select>
    </label>
    <button id="refreshBtn">Refresh Data</button>
    <div id="status">Idle</div>
  </div>
</header>

<main>
  <table aria-live="polite">
    <thead>
      <tr>
        <th>Symbol</th>
        <th>Prev close %</th>
        <th>Curr close %</th>
        <th>Curr vol %</th>
        <th>Prev vol %</th>
        <th>cond_a</th>
        <th>Short 1h %chg</th>
        <th>Short Diff</th>
      </tr>
    </thead>
    <tbody id="resultsBody">
      <tr><td colspan="8" class="small">Click <strong>Refresh Data</strong> to start scan</td></tr>
    </tbody>
  </table>
</main>

<script>
const LIMIT = 3;
const INTERVAL_1H = '1h';
const INTERVAL_15M = '15m';
const MAX_SYMBOLS = 200;
const EXCLUDE = ["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TONUSDT","AVAXUSDT","DOTUSDT","TRXUSDT","SHIBUSDT","LINKUSDT","NEARUSDT","MATICUSDT","LTCUSDT","UNIUSDT","BCHUSDT","ICPUSDT","LEOUSDT"];
const resultsBody = document.getElementById('resultsBody');
const statusEl = document.getElementById('status');
const refreshBtn = document.getElementById('refreshBtn');
const sortSelect = document.getElementById('sortSelect');

let results = [];

async function fetchPerpSymbols(){
  const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
  const data = await res.json();
  return data.symbols.filter(s => s.contractType==='PERPETUAL' && s.symbol.endsWith('USDT') && !EXCLUDE.includes(s.symbol)).map(s=>s.symbol);
}

async function fetchTopSymbols(limit=MAX_SYMBOLS){
  const [tickRes, symbols] = await Promise.all([
    fetch('https://fapi.binance.com/fapi/v1/ticker/24hr'), fetchPerpSymbols()
  ]);
  const tick = await tickRes.json();
  return tick.filter(t=>symbols.includes(t.symbol)).sort((a,b)=>Math.abs(parseFloat(b.priceChangePercent))-Math.abs(parseFloat(a.priceChangePercent))).slice(0,limit).map(t=>t.symbol);
}

async function fetchKlines(symbol, interval, limit=LIMIT){
  const res = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
  const data = await res.json();
  return data.map(r=>({open:+r[1],high:+r[2],low:+r[3],close:+r[4],volume:+r[5]}));
}

async function fetchShortAccounts(symbol, interval){
  const url = `https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${symbol}&period=${interval}&limit=5`;
  const res = await fetch(url);
  const data = await res.json();
  return data.map(d=>parseFloat(d.shortAccount));
}

function pctChange(prev, curr){return prev?((curr-prev)/prev)*100:NaN;}

function checkConditions(symbol, klines, short1h, short1hPrev, short15m){
  const n = klines.length;
  const last = klines[n-1], prev = klines[n-2], prev2 = klines[n-3];
  if(last.volume <= prev.volume || last.volume <= prev2.volume) return null;
  const currClosePct = pctChange(prev.close,last.close);
  if(Math.abs(currClosePct)<=1) return null;

  const cond_a = ((short15m - short1h)/short1h)*100;
  const short1hChange = ((short1h - short1hPrev)/short1hPrev)*100;
  const isGreen = last.close>prev.close;
  const isRed = last.close<prev.close;
  if(isGreen && short15m<=short1h) return null;
  if(isRed && short15m>=short1h) return null;
  if(Math.abs(cond_a)<2*Math.abs(short1hChange)) return null;

  return {
    symbol,
    prevClosePct:pctChange(prev2.close,prev.close),
    currClosePct,
    currVolPct:pctChange(prev.volume,last.volume),
    prevVolPct:pctChange(prev2.volume,prev.volume),
    condA:cond_a,
    short1hChange,
    shortDiff:short15m-short1h
  };
}

function appendRow(obj){
  const tr = document.createElement('tr');
  tr.className='match';
  tr.innerHTML=`<td><strong>${obj.symbol}</strong></td>
  <td>${obj.prevClosePct?.toFixed(2)||'—'}%</td>
  <td>${obj.currClosePct?.toFixed(2)||'—'}%</td>
  <td>${obj.currVolPct?.toFixed(2)||'—'}%</td>
  <td>${obj.prevVolPct?.toFixed(2)||'—'}%</td>
  <td>${obj.condA?.toFixed(2)||'—'}</td>
  <td>${obj.short1hChange?.toFixed(2)||'—'}</td>
  <td>${obj.shortDiff?.toFixed(2)||'—'}</td>`;
  resultsBody.appendChild(tr);
}

function sortResults(list, sortKey){
  const [key, order]=sortKey.split('_'); const multiplier=order==='asc'?1:-1;
  return list.sort((a,b)=>{
    const va=(key in a)?a[key]:NaN, vb=(key in b)?b[key]:NaN;
    if(isNaN(va)&&isNaN(vb)) return 0;
    if(isNaN(va)) return 1*multiplier;
    if(isNaN(vb)) return -1*multiplier;
    return (va-vb)*multiplier;
  });
}

function renderTable(){
  const sel = sortSelect.value;
  const sorted = sortResults([...results], sel);
  resultsBody.innerHTML='';
  if(sorted.length===0){resultsBody.innerHTML='<tr><td colspan="8" class="small">No matches found.</td></tr>'; return;}
  sorted.forEach(r=>appendRow(r));
}

async function runScan(){
  results=[]; resultsBody.innerHTML='<tr><td colspan="8" class="small">Preparing scan...</td></tr>';
  const symbols=await fetchTopSymbols(MAX_SYMBOLS);
  let i=0;
  for(const sym of symbols){
    i++; statusEl.textContent=`Scanning ${i}/${symbols.length}: ${sym}`;
    try{
      const klines1h = await fetchKlines(sym, INTERVAL_1H, LIMIT);
      const short1hArr = await fetchShortAccounts(sym, INTERVAL_1H);
      if(short1hArr.length<2) continue;
      const short1h = short1hArr[short1hArr.length-1];
      const short1hPrev = short1hArr[short1hArr.length-2];
      const lastVol = klines1h[klines1h.length-1].volume;
      const prevVol = klines1h[klines1h.length-2].volume;
      const prev2Vol = klines1h[klines1h.length-3].volume;
      const lastClosePct = pctChange(klines1h[klines1h.length-2].close, klines1h[klines1h.length-1].close);
      if(lastVol>prevVol && lastVol>prev2Vol && Math.abs(lastClosePct)>1){
        const short15mArr = await fetchShortAccounts(sym, INTERVAL_15M);
        const short15m = short15mArr[short15mArr.length-1];
        const obj = checkConditions(sym, klines1h, short1h, short1hPrev, short15m);
        if(obj){results.push(obj); appendRow(obj);}
      }
    }catch(e){console.warn(e);}
    await new Promise(r=>setTimeout(r,90));
  }
  statusEl.textContent=`Scan complete — found ${results.length} matches.`;
  renderTable();
}

refreshBtn.addEventListener('click',()=>{refreshBtn.disabled=true; resultsBody.innerHTML='<tr><td colspan="8" class="small">Starting scan...</td></tr>'; runScan().finally(()=>{refreshBtn.disabled=false;});});
sortSelect.addEventListener('

