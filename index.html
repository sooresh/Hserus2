<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Hserus 2</title>
  <style>
    :root{--bg:#071827;--card:#0b2430;--muted:#9fb6c7;--accent:#7be3c7;--danger:#ff9a9a}
    body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#021119 0%,#051521 100%);color:#e6f3f6;padding:12px}
    header{display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:8px}
    h1{font-size:18px;margin:0}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    select,button{padding:8px;border-radius:8px;border:1px solid #12333d;background:var(--card);color:inherit}
    button{cursor:pointer}
    #status{font-size:13px;color:var(--muted)}
    main{margin-top:12px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{text-align:left;padding:10px;border-bottom:1px solid rgba(255,255,255,0.04)}
    th{color:var(--muted);font-size:12px}
    tr.match{background:linear-gradient(90deg, rgba(11,36,48,0.8), rgba(6,28,36,0.6));border-radius:6px}
    .small{font-size:12px;color:var(--muted)}
    .green{color:#7be3c7}
    .red{color:#ff9a9a}
    @media(max-width:640px){ th,td{padding:8px;font-size:12px} h1{font-size:16px} }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Hserus 2</h1>
      <div class="small">Conditions: last two candle colours different; red → hist[-3] &lt; hist[-2] &lt; hist[-1]; green → hist[-3] &gt; hist[-2] &gt; hist[-1]</div>
    </div>

    <div class="controls">
      <label class="small">Sort:
        <select id="sortOpt">
          <option value="none">None</option>
          <option value="close_desc">Current Δ % ↓</option>
          <option value="close_asc">Current Δ % ↑</option>
          <option value="prev_desc">Prev Δ % ↓</option>
          <option value="prev_asc">Prev Δ % ↑</option>
        </select>
      </label>

      <button id="refreshBtn">Refresh</button>
      <div id="status">Ready</div>
    </div>
  </header>

  <main>
    <table aria-live="polite">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Current Δ %</th>
          <th>Prev Δ %</th>
          <th>RSI(6)</th>
          <th>MACD hist (t-3, t-2, t-1)</th>
          <th class="small">Note</th>
        </tr>
      </thead>
      <tbody id="resultsBody">
        <tr><td colspan="6" class="small">Click Refresh to scan — progress will show above and results will appear live as matches are found.</td></tr>
      </tbody>
    </table>
  </main>

<script>
/* Single-file client-side screener
   - LIMIT = 40 candles
   - Conditions:
     1) last 2 candles have different colors (doji ignored)
     2) red current -> hist[-3] < hist[-2] < hist[-1]
        green current -> hist[-3] > hist[-2] > hist[-1]
   - Shows current and previous candle % change (close vs open)
   - Sort by current or prev % change (asc/desc)
   - Scans top 200 perpetual USDT symbols (by 24h volatility)
*/

const LIMIT = 40;
const INTERVAL = '1h';
const MAX_SYMBOLS = 200;
const EXCLUDE = ["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","ADAUSDT","DOGEUSDT","TONUSDT","AVAXUSDT","DOTUSDT","TRXUSDT","SHIBUSDT","LINKUSDT","NEARUSDT","MATICUSDT","LTCUSDT","UNIUSDT","BCHUSDT","ICPUSDT","LEOUSDT"];

const statusEl = document.getElementById('status');
const resultsBody = document.getElementById('resultsBody');
const refreshBtn = document.getElementById('refreshBtn');
const sortOpt = document.getElementById('sortOpt');

let matches = [];

refreshBtn.addEventListener('click', () => handleRefresh());
sortOpt.addEventListener('change', () => renderMatches());

async function fetchPerpetualSymbols() {
  const url = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
  const res = await fetch(url);
  if (!res.ok) throw new Error('exchangeInfo failed');
  const data = await res.json();
  return data.symbols
    .filter(s => s.contractType === 'PERPETUAL' && s.symbol.endsWith('USDT') && !EXCLUDE.includes(s.symbol))
    .map(s => s.symbol);
}

async function fetchTopSymbols(limit = MAX_SYMBOLS) {
  const url = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
  const [tickRes, perpSymbols] = await Promise.all([fetch(url), fetchPerpetualSymbols()]);
  if (!tickRes.ok) throw new Error('ticker24h failed');
  const tick = await tickRes.json();
  const filtered = tick
    .filter(t => t.symbol.endsWith('USDT') && perpSymbols.includes(t.symbol))
    .sort((a,b) => Math.abs(parseFloat(b.priceChangePercent || 0)) - Math.abs(parseFloat(a.priceChangePercent || 0)))
    .slice(0, limit)
    .map(t => t.symbol);
  return filtered;
}

async function fetchKlines(symbol) {
  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=${LIMIT}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`klines failed ${symbol}`);
  const raw = await res.json();
  return raw.map(r => ({ open:+r[1], high:+r[2], low:+r[3], close:+r[4], volume:+r[5] }) );
}

/* Wilder RSI implementation in JS */
function rsiWilderFromCloses(closes, period = 6) {
  const n = closes.length;
  const deltas = new Array(n).fill(0);
  for (let i=1; i<n; i++) deltas[i] = closes[i] - closes[i-1];

  const gains = new Array(n).fill(0), losses = new Array(n).fill(0);
  for (let i=1; i<n; i++) {
    if (deltas[i] > 0) { gains[i] = deltas[i]; losses[i] = 0; }
    else { gains[i] = 0; losses[i] = -deltas[i]; }
  }

  const avgGain = new Array(n).fill(null), avgLoss = new Array(n).fill(null);
  if (n <= period) return new Array(n).fill(null);

  let sumG = 0, sumL = 0;
  for (let i=1; i<=period; i++) { sumG += gains[i]; sumL += losses[i]; }
  avgGain[period] = sumG / period;
  avgLoss[period] = sumL / period;

  for (let i=period+1; i<n; i++) {
    avgGain[i] = (avgGain[i-1] * (period - 1) + gains[i]) / period;
    avgLoss[i] = (avgLoss[i-1] * (period - 1) + losses[i]) / period;
  }

  const rsi = new Array(n).fill(null);
  for (let i=0;i<n;i++) {
    if (avgGain[i] == null || avgLoss[i] == null) rsi[i] = null;
    else if (avgLoss[i] === 0) rsi[i] = 100;
    else {
      const rs = avgGain[i] / avgLoss[i];
      rsi[i] = 100 - (100 / (1 + rs));
    }
  }
  return rsi;
}

/* EMA array */
function emaArray(values, period) {
  const k = 2 / (period + 1);
  const out = new Array(values.length).fill(null);
  out[0] = values[0];
  for (let i=1; i<values.length; i++) {
    out[i] = values[i] * k + out[i-1] * (1 - k);
  }
  return out;
}

/* MACD arrays and histogram */
function macdArrays(closes, short=12, long=26, signal=9) {
  const emaShort = emaArray(closes, short);
  const emaLong = emaArray(closes, long);
  const macd = closes.map((_,i) => (emaShort[i] !== null && emaLong[i] !== null) ? (emaShort[i] - emaLong[i]) : 0);
  const signalArr = emaArray(macd, signal);
  const hist = macd.map((v,i) => v - signalArr[i]);
  return { macd, signalArr, hist };
}

/* helpers */
function candleColor(c) { if (c.close > c.open) return 'green'; if (c.close < c.open) return 'red'; return 'doji'; }
function checkColorChange(prev, last) { const pc = candleColor(prev), lc = candleColor(last); return (pc !== lc) && pc !== 'doji' && lc !== 'doji'; }
function histIncreasingLast3(hist) { if (hist.length < 3) return false; const a = hist[hist.length-3], b = hist[hist.length-2], c = hist[hist.length-1]; return (a < b) && (b < c); }
function histDecreasingLast3(hist) { if (hist.length < 3) return false; const a = hist[hist.length-3], b = hist[hist.length-2], c = hist[hist.length-1]; return (a > b) && (b > c); }
function percentChange(open, close) { if (!open) return 0; return ((close - open) / open) * 100; }

/* append row (live) */
function appendMatchRow(obj) {
  // if sorting is active, we'll re-render all matches sorted, otherwise append live
  const sort = sortOpt.value;
  if (sort === 'none') {
    const tr = document.createElement('tr');
    tr.className = 'match';
    tr.innerHTML = `
      <td><strong>${obj.symbol}</strong></td>
      <td class="${obj.currPct >= 0 ? 'green' : 'red'}">${obj.currPct.toFixed(2)}%</td>
      <td class="${obj.prevPct >= 0 ? 'green' : 'red'}">${obj.prevPct.toFixed(2)}%</td>
      <td>${obj.rsi.toFixed(2)}</td>
      <td class="small">${obj.hist.map(v => v.toFixed(6)).join(', ')}</td>
      <td class="small">${obj.note}</td>
    `;
    resultsBody.appendChild(tr);
  } else {
    // if sorted view active, re-render all matches (so the new one appears in sorted order)
    renderMatches();
  }
}

/* render matches sorted according to dropdown */
function renderMatches() {
  const opt = sortOpt.value;
  let sorted = [...matches];
  if (opt === 'close_desc') sorted.sort((a,b) => b.currPct - a.currPct);
  else if (opt === 'close_asc') sorted.sort((a,b) => a.currPct - b.currPct);
  else if (opt === 'prev_desc') sorted.sort((a,b) => b.prevPct - a.prevPct);
  else if (opt === 'prev_asc') sorted.sort((a,b) => a.prevPct - b.prevPct);
  // clear table
  resultsBody.innerHTML = '';
  if (sorted.length === 0) {
    resultsBody.innerHTML = '<tr><td colspan="6" class="small">No matches yet.</td></tr>';
    return;
  }
  for (const m of sorted) {
    const tr = document.createElement('tr');
    tr.className = 'match';
    tr.innerHTML = `
      <td><strong>${m.symbol}</strong></td>
      <td class="${m.currPct >= 0 ? 'green' : 'red'}">${m.currPct.toFixed(2)}%</td>
      <td class="${m.prevPct >= 0 ? 'green' : 'red'}">${m.prevPct.toFixed(2)}%</td>
      <td>${m.rsi.toFixed(2)}</td>
      <td class="small">${m.hist.map(v => v.toFixed(6)).join(', ')}</td>
      <td class="small">${m.note}</td>
    `;
    resultsBody.appendChild(tr);
  }
}

/* main scanning loop */
async function runScan() {
  try {
    matches = [];
    resultsBody.innerHTML = '<tr><td colspan="6" class="small">Preparing scan...</td></tr>';
    statusEl.textContent = 'Preparing symbols...';
    const symbols = await fetchTopSymbols(MAX_SYMBOLS);
    statusEl.textContent = `Scanning 0 / ${symbols.length}`;

    let idx = 0;
    for (const sym of symbols) {
      idx++;
      statusEl.textContent = `Scanning ${idx} / ${symbols.length}: ${sym}`;
      try {
        const klines = await fetchKlines(sym);
        if (!klines || klines.length < 10) { await sleep(80); continue; }

        const last = klines[klines.length-1];
        const prev = klines[klines.length-2];

        if (!checkColorChange(prev, last)) { await sleep(80); continue; }

        const closes = klines.map(k => k.close);
        const rsiArr = rsiWilderFromCloses(closes, 6);
        const rsiNow = rsiArr[rsiArr.length -1];
        if (rsiNow == null) { await sleep(80); continue; }

        const { hist } = macdArrays(closes, 12, 26, 9);
        if (hist.length < 3) { await sleep(80); continue; }

        const color = candleColor(last);
        let condOk = false;
        if (color === 'red') condOk = histIncreasingLast3(hist);
        else if (color === 'green') condOk = histDecreasingLast3(hist);

        if (!condOk) { await sleep(80); continue; }

        // compute current and previous candle % change (close vs open)
        const prevOpen = klines[klines.length-2].open;
        const prevClose = klines[klines.length-2].close;
        const lastOpen = klines[klines.length-1].open;
        const lastClose = klines[klines.length-1].close;
        const prevPct = percentChange(prevOpen, prevClose);
        const currPct = percentChange(lastOpen, lastClose);

        const match = {
          symbol: sym,
          currPct: Number(currPct),
          prevPct: Number(prevPct),
          rsi: Number(rsiNow),
          hist: [hist[hist.length-3], hist[hist.length-2], hist[hist.length-1]],
          note: color
        };

        matches.push(match);
        appendMatchRow(match);
      } catch (e) {
        // ignore symbol errors
      }
      await sleep(90); // small delay to keep UI responsive & avoid bursts
    }

    statusEl.textContent = `Scan complete — ${matches.length} matches found.`;
    // if user currently has a sorted view, ensure final sorted rendering
    if (sortOpt.value !== 'none') renderMatches();
  } catch (err) {
    console.error(err);
    statusEl.textContent = 'Error: ' + (err.message || err);
  }
}

/* small sleep */
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function handleRefresh() {
  refreshBtn.disabled = true;
  resultsBody.innerHTML = '<tr><td colspan="6" class="small">Starting scan...</td></tr>';
  await runScan();
  refreshBtn.disabled = false;
}

/* auto-run once on page load */
handleRefresh();

</script>
</body>
</html>

